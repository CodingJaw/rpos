// This file is generated by the 'node-soap-servicegenerator'
// visit : https://github.com/BreeeZe/node-soap-servicegenerator for more info

const { URL } = require('url');
const crypto = require('crypto');
const utils = require('../lib/utils').Utils.utils;

const PATH = '/onvif/events_service';

const registry = new Map();

function generateSubscriptionReference(req) {
  const host = req && req.headers && req.headers.host ? req.headers.host : `${utils.getIpAddress()}:${process.env.SERVICE_PORT || 8080}`;
  const id = crypto.randomUUID ? crypto.randomUUID() : Math.random().toString(36).slice(2);
  return `http://${host}${PATH}?subscription=${id}`;
}

function resolveTermination(termination, fallback) {
  if (!termination) {
    return new Date(fallback.getTime() + 60 * 60 * 1000);
  }
  const parsed = new Date(termination);
  if (!isNaN(parsed.getTime())) {
    return parsed;
  }
  return new Date(fallback.getTime() + 60 * 60 * 1000);
}

function normalizeReference(reference) {
  try {
    const url = new URL(reference, `http://${utils.getIpAddress()}:${process.env.SERVICE_PORT || 8080}`);
    return url.toString();
  } catch (err) {
    return reference;
  }
}

function getSubscriptionReference(args, headers, req) {
  const candidates = [];
  candidates.push(args && (args.SubscriptionReference && args.SubscriptionReference.Address || args.SubscriptionReference));
  candidates.push(headers && (headers.To || headers.wsa__To));
  if (req && req.url && req.headers && req.headers.host) {
    candidates.push(`http://${req.headers.host}${req.url}`);
  }

  for (const candidate of candidates) {
    if (!candidate) continue;
    const normalized = normalizeReference(candidate);
    if (registry.has(normalized)) {
      return normalized;
    }
  }
  return undefined;
}

function resourceUnknownFault(reference) {
  return {
    Fault: {
      Code: {
        Value: 'soap:Sender'
      },
      Reason: {
        Text: {
          attributes: {
            'xml:lang': 'en'
          },
          $value: `Unknown subscription reference ${reference}`
        }
      }
    }
  };
}

function getSubscription(args, headers, req) {
  const reference = getSubscriptionReference(args, headers, req);
  if (!reference) {
    throw resourceUnknownFault('');
  }
  const subscription = registry.get(reference);
  if (!subscription) {
    throw resourceUnknownFault(reference);
  }
  return subscription;
}

var exports = module.exports = {};

exports.EventService = {
  EventService: {
    EventPort: {
      CreatePullPointSubscription: function(args /*, cb, headers*/ , _headers, req) {
        const now = new Date();
        const termination = resolveTermination(args && args.InitialTerminationTime, now);
        const reference = generateSubscriptionReference(req);

        const subscription = {
          reference,
          createdAt: now,
          terminationTime: termination,
          filters: args && args.Filter,
          notifications: [],
          cursor: 0
        };

        registry.set(reference, subscription);

        return {
          SubscriptionReference: {
            Address: reference
          },
          CurrentTime: now.toISOString(),
          TerminationTime: termination.toISOString()
        };
      },
      PullMessages: function(args, _cb, headers, req) {
        const subscription = getSubscription(args, headers, req);

        const limit = Math.max(0, args && args.MessageLimit || 0);
        const available = subscription.notifications.length - subscription.cursor;
        const count = limit > 0 ? Math.min(limit, available) : available;

        const messages = subscription.notifications
          .slice(subscription.cursor, subscription.cursor + count)
          .map((entry) => entry.message);

        subscription.cursor += count;

        if (subscription.cursor > 50) {
          subscription.notifications = subscription.notifications.slice(subscription.cursor);
          subscription.cursor = 0;
        }

        return {
          CurrentTime: new Date().toISOString(),
          TerminationTime: subscription.terminationTime.toISOString(),
          NotificationMessage: messages
        };
      },
      Seek: function(args, _cb, headers, req) {
        const subscription = getSubscription(args, headers, req);
        const targetTime = args && args.UtcTime ? new Date(args.UtcTime) : null;
        if (targetTime && !isNaN(targetTime.getTime())) {
          subscription.cursor = subscription.notifications.findIndex((entry) => entry.timestamp >= targetTime);
          if (subscription.cursor === -1) {
            subscription.cursor = subscription.notifications.length;
          }
        }
        return {};
      },
      SetSynchronizationPoint: function(args, _cb, headers, req) {
        const subscription = getSubscription(args, headers, req);
        subscription.cursor = subscription.notifications.length;
        return {};
      },
      Unsubscribe: function(args, _cb, headers, req) {
        const subscription = getSubscription(args, headers, req);
        registry.delete(subscription.reference);
        return {};
      }
    }
  }
};
